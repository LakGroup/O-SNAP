% -------------------------------------------------------------------------
% run_OSNAP_classification.m
% -------------------------------------------------------------------------
% Creates a classification model trained on the feature_data. If feature
% selection or PCA information is provided, the model will incorporate
% them. If test data is provided, the classifier is also returned with
% information on its performance classifying the test data, but otherwise,
% cross-validation results are used instead.
%
% Example on how to use it:
%   run_OSNAP_classification(feature_data)
% -------------------------------------------------------------------------
% Input:
%   train_data: The feature data of the training set, where each row  
%               represents a sample(nucleus). The first three columns 
%               represent (1) Group/Phenotype, (2) replicate, and (3)  
%               SampleIdentifier. Each subsequent column is  an O-SNAP 
%               feature.
% Output:
%   classifier: A struct array of the trained classifier. Contains multiple
%               fields related to the performance of the model instance
%                 - PCACenters: Centers from PCA analysis
%                 - PCACoefficients: Coefficients from PCA analysis
%                 - RequiredVariables: The variables required by the
%                                      classifier
%                 - ModelType: Model architecture type
%                 - ClassificationModel: MATLAB object of the classifier
%                 - About: Brief string on classifier information
%                 - HowToPredict: String instructions on how to perform
%                                 function call with model for prediction
%                 - predictFcn: The prediction function
%                 - TestResponse: The true phenotype labels from test data,
%                                 if provided
%                 - TestScores: The prediction scores derived from applying
%                               the model to test data, if provided
%                 - TestPredictions: The predicted phenotype labels from 
%                                    test data, if provided
%                 - TestAccuracy: The accuracy of the classifier on test
%                                 data, if provided
%                 - ValidationPredictions: The predicted phenotype labels  
%                                          from validation data, if test   
%                                          data is not provided
%                 - ValidationScores: The prediction scores from validation
%                                     data, if test data is not provided
%                 - ValidationResponse: The true phenotype labels from 
%                                       validation data, if test data is 
%                                       not provided
%                 - ValidationAccuracy: The accuracy of the classifier on 
%                                       validation data, if test data is 
%                                       not provided
%                 - PerformanceCurve: A cell array where each cell contains
%                                     data on the ROC curve for each group
%                       - group: The phenotype identifier
%                       - x: The False Positive Rate (FPR) values
%                       - y: The True Positive Rate (TPR) values
%                       - threshold: Threshold values for the classifier
%                       - AUC: Area under the curve for the ROC curve
% Options:
%   test_data: A set of O-SNAP feature data for test samples. If no test
%              data is provided, the classifier will undergo
%              cross-validation using feature_data
%   pca_result: Info on PCA transformation
%   vars_selected: Info on feature selection
%   model_type: Desired model architecture type
%   k: Number of folds
%   verbose: Flag for output to print
% -------------------------------------------------------------------------
% Code written by:
%   Hannah Kim          Lakadamyali lab, University of Pennsylvania (USA)
% Contact:
%   hannah.kim3@pennmedicine.upenn.edu
%   melike.lakadamyali@pennmedicine.upenn.edu
% If used, please cite:
%   ....
% -------------------------------------------------------------------------
%%
function classifier = run_OSNAP_classification(train_data,options)
arguments
    train_data table
    options.test_data = []
    options.pca_result struct = []
    options.vars_selected cell = {}
    options.model_type string = 'tree_fine'
    options.k double = 5;
    options.verbose logical = false
end
valid_model_types = ["tree_fine","tree_medium","tree_coarse",...
    "discriminant_linear","discriminant_quadratic",...
    "logistic_regression_binary_glm",...
    "logistic_regression_efficient","svm_efficient_linear",...
    "naive_bayes_gaussian","naive_bayes_kernel",...
    "svm_linear","svm_quadratic",...
    "svm_gaussian_fine","svm_gaussian_medium","svm_gaussian_coarse",...
    "knn_fine","knn_medium","knn_coarse","knn_cosine","knn_cubic","knn_weighted",...
    "ensemble_boosted_trees","ensemble_bagged_trees","ensemble_subspace_discriminant","ensemble_rus_boosted_trees",...
    "NN_narrow","NN_medium","NN_wide","NN_bilayered","NN_trilayered",...
    "kernel_svm","kernel_logistic_regression"];
assert(ismember(options.model_type,valid_model_types),...
    'SNAP:invalid_classification_model',...
    'Invalid model type: %s, choose from following valid models:\ntree_fine,tree_medium,tree_coarse,\ndiscriminant_linear,discriminant_quadratic,\nlogistic_regression_binary_glm,\nlogistic_regression_efficient,svm_efficient_linear,\nnaive_bayes_gaussian,naive_bayes_kernel,\nsvm_linear,svm_quadratic,\nsvm_gaussian_fine,svm_gaussian_medium,svm_gaussian_coarse,\nknn_fine,knn_medium,knn_coarse,knn_cosine,knn_cubic,knn_weighted,\nensemble_boosted_trees,ensemble_bagged_trees,ensemble_subspace_discriminant,ensemble_rus_boosted_trees,\nNN_narrow,NN_medium,NN_wide,NN_bilayered,NN_trilayered,\nkernel_svm,kernel_logistic_regression',options.model_type);

classifier = struct();

train_data = preprocess_OSNAP_feature_data(train_data,'normalize',false);

%% Get class names (groups) and predictors (preprocessed feature data)
% Also adds information depending on if variable selection or PCA info is
% passed to the function. Variable selection information from a PCA takes
% precedence over ones passed into the function, if they are inconsistent.
if ~isempty(options.pca_result)
    [train_data,response] = preprocess_OSNAP_feature_data(train_data,'numeric_only',true);
    pca_result = options.pca_result;
    predictors = pca_result.pca_transformation_fcn(train_data);
    classifier.PCACenters = pca_result.pca_centers;
    classifier.PCACoefficients = pca_result.pca_coefficients;
    classifier.RequiredVariables = pca_result.vars_selected;
elseif ~isempty(options.vars_selected)
    [predictors,response] = preprocess_OSNAP_feature_data(train_data(:,['group' options.vars_selected]),'numeric_only',true);
    classifier.RequiredVariables = options.vars_selected;
else
    [predictors,response] = preprocess_OSNAP_feature_data(train_data,'numeric_only',true);
    classifier.RequiredVariables = predictors.Properties.VariableNames;
end

%% Train a classifier
% This code specifies all the classifier options and trains the classifier.
[classification_model, predict_fcn] = get_model(options.model_type,predictors,response);
% Add additional fields to the result struct
classifier.ModelType = options.model_type;
classifier.ClassificationModel = classification_model;
classifier.About = 'This struct is a trained model exported from R2024b using O-SNAP.';
classifier.HowToPredict = sprintf('To make predictions on a new table, T, use: \n  [yfit,scores] = c.predictFcn(T) \nreplace ''c'' with the name of the variable that is this struct, e.g. ''trainedModel''. \n \nThe table, T, must contain the variables returned by: \n  c.RequiredVariables \nVariable formats (e.g. matrix/vector, datatype) must match the original training data. \nAdditional variables are ignored. \n \nFor more information, see <a href="matlab:helpview(fullfile(docroot, ''stats'', ''stats.map''), ''appclassification_exportmodeltoworkspace'')">How to predict using an exported model</a>.');
% Create the result struct with predict function
if ~isempty(options.pca_result)
    classifier.predictFcn = @(x) predict_fcn(pca_result.pca_transformation_fcn(x));
else
    predictor_extraction_fcn = @(t) normalize(t(~any(ismissing(t),2), classifier.RequiredVariables));
    classifier.predictFcn = @(x) predict_fcn(predictor_extraction_fcn(x));
end

%% Calculate accuracy on test data
if ~isempty(options.test_data)
    [test_data, classifier.TestResponse] = preprocess_OSNAP_feature_data(options.test_data,'numeric_only',true);
    [test_predictions, test_scores] = classifier.predictFcn(test_data);
    classifier.TestScores = test_scores;
    classifier.TestPredictions = strtrim(test_predictions);
    classifier.TestResponse = strtrim(classifier.TestResponse);
    correct_predictions = strcmp(...
        classifier.TestPredictions,...
        classifier.TestResponse);
    classifier.TestAccuracy = sum(correct_predictions)/numel(correct_predictions);
    groups = unique(classifier.TestResponse);
    classifier.PerformanceCurve = cell(numel(groups),1);
    for i=1:numel(groups)
        classifier.PerformanceCurve{i}.group = groups(i);
        [classifier.PerformanceCurve{i}.x,classifier.PerformanceCurve{i}.y,classifier.PerformanceCurve{i}.threshold,classifier.PerformanceCurve{i}.AUC] = perfcurve(classifier.TestResponse,classifier.TestScores(:,i),groups(i));
    end
    % Show results
    if options.verbose
        fprintf('Model: %s\n  Acc: %5.2f\n',options.model_type,classifier.TestAccuracy*100)
    end

%% Calculate validation accuracy if no test data is given
else
    % Perform cross-validation
    options.k = 5;
    cvp = cvpartition(response, 'KFold', options.k);
    % Initialize the predictions to the proper sizes
    classifier.ValidationPredictions = response;
    n_obs = size(predictors,1);
    n_groups = numel(unique(response));
    classifier.ValidationScores = NaN(n_obs,n_groups);
    for k = 1:options.k
        % split train from test
        train_k = train_data(cvp.training(k),:);
        % PCA on train data
        if ~isempty(options.pca_result)
            [train_k,response_k] = preprocess_OSNAP_feature_data(train_k,'numeric_only',true);
            pca_result_k = run_OSNAP_PCA(train_k,...
                                "vars_sel",options.vars_selected,...
                                "num_components_explained",options.pca_result.num_comps_to_keep);
            predictors_k = pca_result_k.pca_transformation_fcn(train_k);
        elseif ~isempty(options.vars_selected)
            [predictors_k,response_k] = preprocess_OSNAP_feature_data(train_k(:,['group' options.vars_selected]),'numeric_only',true);
        else
            [predictors_k,response_k] = preprocess_OSNAP_feature_data(train_k,'numeric_only',true);
        end
        % Train classifier
        [~, predict_fcn_k] = get_model(options.model_type,predictors_k,response_k);
        if ~isempty(options.pca_result)
            predictFcn_k = @(x) predict_fcn_k(pca_result_k.pca_transformation_fcn(x));
        else
            predictor_extraction_fcn_k = @(t) normalize(t(~any(ismissing(t),2), classifier.RequiredVariables));
            predictFcn_k = @(x) predict_fcn_k(predictor_extraction_fcn_k(x));
        end
        % Compute validation predictions
        test_k = train_data(cvp.test(k),:);
        [predictors_k, ~] = preprocess_OSNAP_feature_data(test_k,'numeric_only',true);
        [predictions_k, scores_k] = predictFcn_k(predictors_k);
        % Store predictions in the original order
        classifier.ValidationPredictions(cvp.test(k), :) = strtrim(predictions_k);
        classifier.ValidationScores(cvp.test(k),:) = scores_k;
    end
    correct_predictions = strcmp(classifier.ValidationPredictions,strtrim(response));
    classifier.ValidationResponse = strtrim(response);
    classifier.ValidationAccuracy = sum(correct_predictions)/numel(correct_predictions);
    groups = unique(classifier.ValidationResponse);
    classifier.PerformanceCurve = cell(numel(groups),1);
    for i=1:numel(groups)
        classifier.PerformanceCurve{i}.group = groups(i);
        [classifier.PerformanceCurve{i}.x,classifier.PerformanceCurve{i}.y,classifier.PerformanceCurve{i}.threshold,classifier.PerformanceCurve{i}.AUC] = perfcurve(classifier.ValidationResponse,classifier.ValidationScores(:,i),groups(i));
    end
    % Show results
    if options.verbose
        fprintf('Model: %s\n  Acc: %5.2f\n',options.model_type,classifier.ValidationAccuracy*100)
    end
end

end

function [classification_model, predict_fcn] = get_model(model_type,predictors,response)
class_names = unique(response);
switch model_type
    case 'tree_fine'
        classification_model = fitctree(...
            predictors, ...
            response, ...
            'SplitCriterion', 'gdi', ...
            'MaxNumSplits', 100, ...
            'Surrogate', 'off', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'tree_medium'
        classification_model = fitctree(...
            predictors, ...
            response, ...
            'SplitCriterion', 'gdi', ...
            'MaxNumSplits', 20, ...
            'Surrogate', 'off', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'tree_coarse'
        classification_model = fitctree(...
            predictors, ...
            response, ...
            'SplitCriterion', 'gdi', ...
            'MaxNumSplits', 4, ...
            'Surrogate', 'off', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'discriminant_linear'
        classification_model = fitcdiscr(...
            predictors, ...
            response, ...
            'DiscrimType', 'linear', ...
            'Gamma', 0, ...
            'FillCoeffs', 'off', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'discriminant_quadratic'
        classification_model = fitcdiscr(...
            predictors, ...
            response, ...
            'DiscrimType', 'quadratic', ...
            'FillCoeffs', 'off', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'logistic_regression_binary_glm'
        if length(class_names) > 2
            ME = MException('SNAP:too_many_classes_binary_glm', ...
                sprintf('Too many classes (%d); incompatible with binary glm',numel(class_names)));
            throw(ME)
        else
            % For logistic regression, the response values must be converted to zeros
            % and ones because the responses are assumed to follow a binomial
            % distribution.
            % 1 or true = 'successful' class
            % 0 or false = 'failure' class
            % NaN - missing response.
            successClass = class_names{1};
            failureClass = class_names{2};
            % Compute the majority response class. If there is a NaN-prediction from
            % fitglm, convert NaN to this majority class label.
            numSuccess = sum(strcmp(strtrim(response), successClass));
            numFailure = sum(strcmp(strtrim(response), failureClass));
            if numSuccess > numFailure
                missingClass = successClass;
            else
                missingClass = failureClass;
            end
            successFailureAndMissingClasses = {successClass; failureClass; missingClass};
            isMissing = cellfun(@(x) isempty(strtrim(x)), response);
            zeroOneResponse = double(strcmp(strtrim(response), successClass));
            zeroOneResponse(isMissing) = NaN;
            % Prepare input arguments to fitglm.
            concatenatedPredictorsAndResponse = [predictors, table(zeroOneResponse)];
            % Train using fitglm.
            classification_model = fitglm(...
                concatenatedPredictorsAndResponse, ...
                'Distribution', 'binomial', ...
                'link', 'logit');
            % Convert predicted probabilities to predicted class labels and scores.
            convertSuccessProbsToPredictions = @(p) successFailureAndMissingClasses( ~isnan(p).*( (p<0.5) + 1 ) + isnan(p)*3 );
            returnMultipleValuesFcn = @(varargin) varargin{1:max(1,nargout)};
            scoresFcn = @(p) [p, 1-p];
            predictionsAndScoresFcn = @(p) returnMultipleValuesFcn( convertSuccessProbsToPredictions(p), scoresFcn(p) );
            predict_fcn = @(x) predictionsAndScoresFcn( predict(classification_model, x) );
        end
    case 'logistic_regression_efficient'
        template = templateLinear(...
            'Learner', 'Logistic', ...
            'Lambda', 'auto', ...
            'BetaTolerance', 0.0001);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'svm_efficient_linear'
        if numel(class_names)>2
            template = templateLinear(...
                'Learner', 'SVM', ...
                'Lambda', 'auto', ...
                'BetaTolerance', 0.0001);
            classification_model = fitcecoc(...
                predictors, ...
                response, ...
                'Learners', template, ...
                'Coding', 'onevsone', ...
                'ClassNames', class_names);
        else
            classification_model = fitclinear(...
                predictors, ...
                response, ...
                'Learner', 'Logistic', ...
                'Lambda', 'auto', ...
                'BetaTolerance', 0.0001, ...
                'ClassNames', class_names);
        end
        predict_fcn = @(x) predict(classification_model, x);
    case 'naive_bayes_gaussian'
        % Expand the Distribution Names per predictor
        % Numerical predictors are assigned either Gaussian or Kernel distribution
        % Gaussian is replaced with Normal when passing to the fitcnb function
        distributionNames =  repmat({'Normal'}, 1, size(predictors,2));
        if any(strcmp(distributionNames,'Kernel'))
            classification_model = fitcnb(...
                predictors, ...
                response, ...
                'Kernel', 'Normal', ...
                'Support', 'Unbounded', ...
                'Standardize', false, ...
                'DistributionNames', distributionNames, ...
                'ClassNames', class_names);
        else
            classification_model = fitcnb(...
                predictors, ...
                response, ...
                'DistributionNames', distributionNames, ...
                'ClassNames', class_names);
        end
        predict_fcn = @(x) predict(classification_model, x);
    case 'naive_bayes_kernel'
        distributionNames =  repmat({'Kernel'}, 1, size(predictors,2));
        if any(strcmp(distributionNames,'Kernel'))
            classification_model = fitcnb(...
                predictors, ...
                response, ...
                'Kernel', 'Normal', ...
                'Support', 'Unbounded', ...
                'Standardize', true, ...
                'DistributionNames', distributionNames, ...
                'ClassNames', class_names);
        else
            classification_model = fitcnb(...
                predictors, ...
                response, ...
                'DistributionNames', distributionNames, ...
                'ClassNames', class_names);
        end
        predict_fcn = @(x) predict(classification_model, x);
    case 'svm_linear'
        template = templateSVM(...
            'KernelFunction', 'linear', ...
            'PolynomialOrder', [], ...
            'KernelScale', 'auto', ...
            'BoxConstraint', 1, ...
            'Standardize', true);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'svm_quadratic'
        template = templateSVM(...
            'KernelFunction', 'polynomial', ...
            'PolynomialOrder', 2, ...
            'KernelScale', 'auto', ...
            'BoxConstraint', 1, ...
            'Standardize', true);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'svm_cubic'
        template = templateSVM(...
            'KernelFunction', 'polynomial', ...
            'PolynomialOrder', 3, ...
            'KernelScale', 'auto', ...
            'BoxConstraint', 1, ...
            'Standardize', true);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'svm_gaussian_fine'
        template = templateSVM(...
            'KernelFunction', 'gaussian', ...
            'PolynomialOrder', [], ...
            'KernelScale', 0.71, ...
            'BoxConstraint', 1, ...
            'Standardize', true);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'svm_gaussian_medium'
        template = templateSVM(...
            'KernelFunction', 'gaussian', ...
            'PolynomialOrder', [], ...
            'KernelScale', 2.8, ...
            'BoxConstraint', 1, ...
            'Standardize', true);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'svm_gaussian_coarse'
        template = templateSVM(...
            'KernelFunction', 'gaussian', ...
            'PolynomialOrder', [], ...
            'KernelScale', 11, ...
            'BoxConstraint', 1, ...
            'Standardize', true);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'knn_fine'
        classification_model = fitcknn(...
            predictors, ...
            response, ...
            'Distance', 'Euclidean', ...
            'Exponent', [], ...
            'NumNeighbors', 1, ...
            'DistanceWeight', 'Equal', ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'knn_medium'
        classification_model = fitcknn(...
            predictors, ...
            response, ...
            'Distance', 'Euclidean', ...
            'Exponent', [], ...
            'NumNeighbors', 10, ...
            'DistanceWeight', 'Equal', ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'knn_coarse'
        classification_model = fitcknn(...
            predictors, ...
            response, ...
            'Distance', 'Euclidean', ...
            'Exponent', [], ...
            'NumNeighbors', 100, ...
            'DistanceWeight', 'Equal', ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'knn_cosine'
        classification_model = fitcknn(...
            predictors, ...
            response, ...
            'Distance', 'Cosine', ...
            'Exponent', [], ...
            'NumNeighbors', 10, ...
            'DistanceWeight', 'Equal', ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'knn_cubic'
        classification_model = fitcknn(...
            predictors, ...
            response, ...
            'Distance', 'Minkowski', ...
            'Exponent', 3, ...
            'NumNeighbors', 10, ...
            'DistanceWeight', 'Equal', ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'knn_weighted'
        classification_model = fitcknn(...
            predictors, ...
            response, ...
            'Distance', 'Euclidean', ...
            'Exponent', [], ...
            'NumNeighbors', 10, ...
            'DistanceWeight', 'SquaredInverse', ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'ensemble_boosted_trees'
        if numel(class_names) == 2
            method_boost = 'AdaBoostM1';
        else
            method_boost = 'AdaBoostM2';
        end
        template = templateTree(...
            'MaxNumSplits', 20, ...
            'NumVariablesToSample', 'all');
        classification_model = fitcensemble(...
            predictors, ...
            response, ...
            'Method', method_boost, ...
            'NumLearningCycles', 30, ...
            'Learners', template, ...
            'LearnRate', 0.1, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'ensemble_bagged_trees'
        template = templateTree(...
            'MaxNumSplits', 428, ...
            'NumVariablesToSample', 'all');
        classification_model = fitcensemble(...
            predictors, ...
            response, ...
            'Method', 'Bag', ...
            'NumLearningCycles', 30, ...
            'Learners', template, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'ensemble_subspace_discriminant'
        subspaceDimension = max(1, min(4, width(predictors) - 1));
        classification_model = fitcensemble(...
            predictors, ...
            response, ...
            'Method', 'Subspace', ...
            'NumLearningCycles', 30, ...
            'Learners', 'discriminant', ...
            'NPredToSample', subspaceDimension, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'ensemble_subspace_knn'
        subspaceDimension = max(1, min(4, width(predictors) - 1));
        classification_model = fitcensemble(...
            predictors, ...
            response, ...
            'Method', 'Subspace', ...
            'NumLearningCycles', 30, ...
            'Learners', 'knn', ...
            'NPredToSample', subspaceDimension, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'ensemble_rus_boosted_trees'
        template = templateTree(...
            'MaxNumSplits', 20, ...
            'NumVariablesToSample', 'all');
        classification_model = fitcensemble(...
            predictors, ...
            response, ...
            'Method', 'RUSBoost', ...
            'NumLearningCycles', 30, ...
            'Learners', template, ...
            'LearnRate', 0.1, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'NN_narrow'
        classification_model = fitcnet(...
            predictors, ...
            response, ...
            'LayerSizes', 10, ...
            'Activations', 'relu', ...
            'Lambda', 0, ...
            'IterationLimit', 1000, ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'NN_medium'
        classification_model = fitcnet(...
            predictors, ...
            response, ...
            'LayerSizes', 25, ...
            'Activations', 'relu', ...
            'Lambda', 0, ...
            'IterationLimit', 1000, ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'NN_wide'
        classification_model = fitcnet(...
            predictors, ...
            response, ...
            'LayerSizes', 100, ...
            'Activations', 'relu', ...
            'Lambda', 0, ...
            'IterationLimit', 1000, ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'NN_bilayered'
        classification_model = fitcnet(...
            predictors, ...
            response, ...
            'LayerSizes', [10 10], ...
            'Activations', 'relu', ...
            'Lambda', 0, ...
            'IterationLimit', 1000, ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'NN_trilayered'
        classification_model = fitcnet(...
            predictors, ...
            response, ...
            'LayerSizes', [10 10 10], ...
            'Activations', 'relu', ...
            'Lambda', 0, ...
            'IterationLimit', 1000, ...
            'Standardize', true, ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'kernel_svm'
        template = templateKernel(...
            'Learner', 'svm', ...
            'NumExpansionDimensions', 'auto', ...
            'Lambda', 'auto', ...
            'KernelScale', 'auto', ...
            'Standardize', true, ...
            'IterationLimit', 1000);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    case 'kernel_logistic_regression'
        template = templateKernel(...
            'Learner', 'logistic', ...
            'NumExpansionDimensions', 'auto', ...
            'Lambda', 'auto', ...
            'KernelScale', 'auto', ...
            'Standardize', true, ...
            'IterationLimit', 1000);
        classification_model = fitcecoc(...
            predictors, ...
            response, ...
            'Learners', template, ...
            'Coding', 'onevsone', ...
            'ClassNames', class_names);
        predict_fcn = @(x) predict(classification_model, x);
    otherwise
        ME = MException('SNAP:invalid_classification_model', ...
                'Invalid model type: %s, choose from following valid models:\ntree_fine,tree_medium,tree_coarse,\ndiscriminant_linear,discriminant_quadratic,\nlogistic_regression_binary_glm,\nlogistic_regression_efficient,svm_efficient_linear,\nnaive_bayes_gaussian,naive_bayes_kernel,\nsvm_linear,svm_quadratic,\nsvm_gaussian_fine,svm_gaussian_medium,svm_gaussian_coarse,\nknn_fine,knn_medium,knn_coarse,knn_cosine,knn_cubic,knn_weighted,\nensemble_boosted_trees,ensemble_bagged_trees,ensemble_subspace_discriminant,ensemble_rus_boosted_trees,\nNN_narrow,NN_medium,NN_wide,NN_bilayered,NN_trilayered,\nkernel_svm,kernel_logistic_regression',model_type);
        throw(ME)
end
end
