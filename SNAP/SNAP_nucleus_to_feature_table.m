function T = SNAP_nucleus_to_feature_table(SNAP_nucleus_file_list)
    %% parameters
    percentile_thresh = [40 70];
    %% define variables of interest
    vars_string = ["group","biological_replicate","name"];
    vars_morphological = [...
        "major_axis",...
        "minor_axis",...
        "convex_area",...
        "gyration_radius",...
        "eigenvalues_ratio",...
        "eigenentropy",...
        "perimeter",...
        "convex_perimeter",...
        "aspect_ratio",...
        "form_ratio",...
        "rectangularity",...
        "circularity",...
        "convex_circularity",...
        "convexity",...
        "solidity",...
        "fiber_length",...
        "fiber_width",...
        "curl",...
        "major_axis_norm_area",...
        "minor_axis_norm_area",...
        "elastic_energy_norm_area",...
        "bending_energy_norm_area"];
    vars_value = [...
        "nucleus_radius",...
        "locs_density",...
        "locs_number",...
        "elastic_energy",...
        "bending_energy",...
        "periphery_loc_density",...
        "interior_loc_density",...
        "periphery_cluster_density",...
        "interior_cluster_density",...
        "model_lad_thickness"];
    vars_ratio = [...
        "periphery_to_interior_loc_density_ratio",...
        "periphery_to_interior_dbscan_cluster_density_ratio"];
    vars_ratio_components = {...
        ["periphery_loc_density","interior_loc_density"],...
        ["periphery_cluster_density","interior_cluster_density"]};
    vars_for_percentiles = ["log_voronoi_density","reduced_log_voronoi_density"];
    vars_chromatin_percentiles = table2array(rowfun(@strcat,combinations(vars_for_percentiles,"_"+percentile_thresh)))';
    vars_distribution_names = [...
        "interior_dbscan_cluster_radius",...
        "interior_dbscan_cluster_density",...
        "interior_dbscan_cluster_n_locs",...
        "periphery_dbscan_cluster_radius",...
        "periphery_dbscan_cluster_density",...
        "periphery_dbscan_cluster_n_locs",...
        "model_lad_segment_length",...
        "model_lad_segment_thickness",...
        "log_voronoi_density",...
        "reduced_log_voronoi_density",...
        "model_lad_segment_spacing",...
        "border_curvature"];
    vars_distribution = reshape(vars_distribution_names + ["_median";"_std";"_skewness"],1,[]);
    vars_lads = [...
        "periphery_dbscan_cluster_n_locs",...
        "interior_dbscan_cluster_n_locs",...
        "periphery_dbscan2total_n_locs",...
        "periphery_dbscan_cluster_n_clusters",...
        "interior_dbscan_cluster_n_clusters",...
        "periphery_dbscan2total_n_clusters"];
    vars_radial_loc_density = compose("radial_loc_density_ring_%02d", 1:10);
    vars_radial_heterochromatin_density = compose("radial_heterochromatin_density_ring_%02d", 1:10);
    vars_radial_delta = [...
        "radial_loc_density_ring_gradient_major_axis",...
        "radial_loc_density_ring_gradient_minor_axis",...
        "radial_heterochromatin_density_ring_gradient_major_axis",...
        "radial_heterochromatin_density_ring_gradient_minor_axis"];
    load(SNAP_nucleus_file_list{1,"filepath"},'area_thresholds');
    vars_cluster = reshape("voronoi_cluster"+compose("_%03.0fnm^2_",area_thresholds)+["radius";"density";"gyration_radius";"n_locs"]+"_",1,[]);
    vars_cluster = reshape(vars_cluster + ["median";"std";"skewness"],1,[]);
    vars_cluster = [vars_cluster reshape("voronoi_cluster"+compose("_%03.0fnm^2_",area_thresholds)+"clusters_per_nucleus_area",1,[])];
    vars = [vars_string,...
        vars_morphological,...
        vars_value,...
        vars_ratio,...
        vars_chromatin_percentiles,...
        vars_distribution,...
        vars_lads,...
        vars_radial_loc_density,...
        vars_radial_heterochromatin_density,...
        vars_radial_delta,...
        vars_cluster];
    vars_to_load = cellstr([vars_value vars_distribution_names,...
        ["area_thresholds"...
        "voronoi_areas",...
        "reduced_log_voronoi_density"...
        "locs_norm",...
        "polygon",...
        "x_length",...
        "y_length",...
        "eigenvalues",...
        "radial_loc_density",...
        "radial_dbscan_cluster_density",...
        "locs_dbscan_cluster_periphery_labels",...
        "locs_dbscan_cluster_interior_labels",...
        "voronoi_cluster_radius",...
        "voronoi_cluster_density",...
        "voronoi_cluster_gyration_radius",...
        "voronoi_cluster_n_locs"]]);
    vars_to_load = setdiff(vars_to_load,'log_voronoi_density');
    % group voronoi data
    n_samp = size(SNAP_nucleus_file_list,1);
    T = table('Size',[n_samp numel(vars)], ...
        'VariableTypes',[repmat("string",numel(vars_string),1); ...
                         repmat("double",numel(vars)-numel(vars_string),1)]',...
        'VariableNames',vars);
    for s=1:n_samp
        %% string variables
        T{s,"group"} = SNAP_nucleus_file_list{s,"group"};
        T{s,"biological_replicate"} = SNAP_nucleus_file_list{s,"rep"};
        [~,a]= regexp(SNAP_nucleus_file_list{s,"name"}, ".*-([x0-9]+).*","split","tokens");
        T{s,"name"} = a{1};
        try
            data = load_variables(SNAP_nucleus_file_list{s,"filepath"},vars_to_load);
            data.log_voronoi_density = log10(1./(data.voronoi_areas));
            %% value variables
            for j=1:numel(vars_value)
                if ~isempty(data.(vars_value(j)))
                    T{s,vars_value(j)} = data.(vars_value(j));
                else
                    T{s,vars_value(j)} = NaN;
                end
            end
            %% ratio variables
            for j=1:numel(vars_ratio)
                v_numerator = vars_ratio_components{j}{1};
                v_denominator = vars_ratio_components{j}{2};
                if ~isempty(data.(v_numerator)) && ~isempty(data.(v_denominator))
                    T{s,vars_ratio(j)} = data.(v_numerator)/data.(v_denominator);
                else
                    T{s,vars_ratio(j)} = NaN;
                end
            end
            %% morphological variables
            locs_norm = data.locs_norm;
            % Generate convex hull
            locs_norm_downsize = locs_norm(1:1000:end,:);
            conv_hull_points = locs_norm_downsize(boundary(locs_norm_downsize,0),:); % Retrieve the actual boundary points.
            polygon_conv_hull_cluster = polyshape(conv_hull_points(1:end-1,1),conv_hull_points(1:end-1,2)); % Create a polygon of the convex hull points (which will be completely filled).
            % Store the shape descriptors: localization descriptors.
            nucleus_area = pi*T{s,"nucleus_radius"}^2;
            T{s,"major_axis"} = max([data.x_length,data.y_length]);
            T{s,"minor_axis"} = min([data.x_length,data.y_length]);
            T{s,"convex_area"} = area(polygon_conv_hull_cluster);
            T{s,"gyration_radius"} = sqrt(mean((locs_norm(:,1)-mean(locs_norm(:,1))).^2 + (locs_norm(:,2)-mean(locs_norm(:,2))).^2));
            eigenvalues = data.eigenvalues;
            T{s,"eigenvalues_ratio"} = eigenvalues(1) / eigenvalues(2);
            T{s,"eigenentropy"} = -eigenvalues(1)/sum(eigenvalues)*log(eigenvalues(1)/sum(eigenvalues)) - eigenvalues(2)/sum(eigenvalues)*log(eigenvalues(2)/sum(eigenvalues));
            % Store the shape descriptors: boundary descriptors.
            T{s,"perimeter"} = perimeter(data.polygon);
            T{s,"convex_perimeter"} = perimeter(polygon_conv_hull_cluster);
            % Store the dependent shape descriptors (coordinate-based).
            T{s,"aspect_ratio"} = T{s,"major_axis"} / T{s,"minor_axis"};
            T{s,"form_ratio"} = nucleus_area / (T{s,"major_axis"}^2);
            T{s,"rectangularity"} = nucleus_area / (T{s,"major_axis"}*T{s,"minor_axis"});
            T{s,"circularity"} = 4 * pi * nucleus_area / (T{s,"perimeter"}^2);
            T{s,"convex_circularity"} = 4 * pi*T{s,"convex_area"} / (T{s,"convex_perimeter"}^2);
            T{s,"convexity"} =  T{s,"convex_perimeter"} / T{s,"perimeter"};
            T{s,"solidity"} = nucleus_area / T{s,"convex_area"};
            T{s,"fiber_length"} = (T{s,"perimeter"} + realsqrt(abs((T{s,"perimeter"})^2 - 16 * nucleus_area))) / 4;
            T{s,"fiber_width"} = nucleus_area / T{s,"fiber_length"};
            T{s,"curl"} = T{s,"major_axis"} / T{s,"fiber_length"};
            T{s,"major_axis_norm_area"} = T{s,"major_axis"} ./ nucleus_area;
            T{s,"minor_axis_norm_area"} = T{s,"minor_axis"} ./ nucleus_area;
            T{s,"elastic_energy_norm_area"} = T{s,"elastic_energy"}./ nucleus_area;            
            T{s,"bending_energy_norm_area"} = T{s,"bending_energy"}./ nucleus_area;            
            %% chromatin variables
            for j=1:numel(vars_for_percentiles)
                percentile_values_j = prctile(data.(vars_for_percentiles(j)),percentile_thresh);
                for k=1:numel(percentile_thresh)
                    T{s,vars_for_percentiles(j)+"_"+percentile_thresh(k)} = percentile_values_j(k);
                end
            end
            %% distribution variables
            for j=1:numel(vars_distribution_names)
                if ~isempty(data.(vars_distribution_names(j)))
                    T{s,vars_distribution_names(j)+"_median"} = median(data.(vars_distribution_names(j)),"omitmissing");
                    T{s,vars_distribution_names(j)+"_std"} = std(data.(vars_distribution_names(j)),"omitmissing");
                    T{s,vars_distribution_names(j)+"_skewness"} = skewness(data.(vars_distribution_names(j)),1);
                else
                    T{s,vars_distribution_names(j)+["_median","_std","_skewness"]} = [NaN NaN NaN];
                end
            end
            %% model lad variables
            T{s,"periphery_dbscan_cluster_n_locs"} = numel(data.locs_dbscan_cluster_periphery_labels);
            T{s,"interior_dbscan_cluster_n_locs"} = numel(data.locs_dbscan_cluster_interior_labels);
            T{s,"periphery_dbscan2total_n_locs"} = T{s,"periphery_dbscan_cluster_n_locs"} /(T{s,"periphery_dbscan_cluster_n_locs"} +T{s,"interior_dbscan_cluster_n_locs"});
            T{s,"periphery_dbscan_cluster_n_clusters"} = numel(data.periphery_dbscan_cluster_n_locs);
            T{s,"interior_dbscan_cluster_n_locs"} = numel(data.interior_dbscan_cluster_n_locs);
            T{s,"periphery_dbscan2total_n_clusters"} = T{s,"periphery_dbscan_cluster_n_clusters"} /(T{s,"periphery_dbscan_cluster_n_clusters"} +T{s,"interior_dbscan_cluster_n_locs"});
            %% radial features
            for j=1:numel(vars_radial_loc_density)
                T{s,vars_radial_loc_density(j)} = data.radial_loc_density(j);
            end
            for j=1:numel(vars_radial_heterochromatin_density)
                T{s,vars_radial_heterochromatin_density(j)} = data.radial_dbscan_cluster_density(j);
            end
            n_ring = floor(numel(vars_radial_loc_density)*0.8);
            T{s,"radial_loc_density_ring_gradient_major_axis"} = mean(data.radial_loc_density(1:n_ring))/(0.8*T{s,"major_axis"});
            T{s,"radial_loc_density_ring_gradient_minor_axis"} = mean(data.radial_loc_density(1:n_ring))/(0.8*T{s,"minor_axis"});
            T{s,"radial_heterochromatin_density_ring_gradient_major_axis"} = mean(data.radial_dbscan_cluster_density(1:n_ring))/(0.8*T{s,"major_axis"});
            T{s,"radial_heterochromatin_density_ring_gradient_minor_axis"} = mean(data.radial_dbscan_cluster_density(1:n_ring))/(0.8*T{s,"minor_axis"});
            %% cluster features
            metrics = ["radius","density","gyration_radius","n_locs"];
            for j=1:numel(metrics)
                for k=1:5
                    prefix = sprintf("voronoi_cluster_%03.0fnm^2_%s_",data.area_thresholds(k),metrics(j));
                    T{s,prefix+"median"} = median(data.("voronoi_cluster_"+metrics(j)){k},"omitmissing");
                    T{s,prefix+"std"} = std(data.("voronoi_cluster_"+metrics(j)){k},"omitmissing");
                    T{s,prefix+"skewness"} = skewness(data.("voronoi_cluster_"+metrics(j)){k},1);
                end
            end
            for k=1:5 
                T{s,sprintf("voronoi_cluster_%03.0fnm^2_clusters_per_nucleus_area",data.area_thresholds(k))} = numel(data.voronoi_cluster_radius{k})/nucleus_area;
            end
            clearvars voronoi_data
        catch ME
            disp(SNAP_nucleus_file_list{s,"filepath"})
            disp(getReport(ME))
            T{s,4:end} = NaN(1,size(T,2)-3);
        end
    end
end
