% -------------------------------------------------------------------------
% extract_OSNAP_features.m
% -------------------------------------------------------------------------
% Creates a table of feature_data where each row represents a sample 
% (nucleus) and the columns are identifier and feature information for the
% sample. The samples analyzed are based on those included in the file list
% list provided, where the code pulls from the saved analysis files on each
% nucleus (stored in the OSNAP_nucleus_data directories).
%
% Example on how to use it:
%   feature_data = extract_OSNAP_features(SNAP_nucleus_file_list)
% -------------------------------------------------------------------------
% Input:
%   SNAP_nucleus_file_list: Table with details on the samples of interest
%                           to extract feature information from, including 
%                           the file path, replicate, phenotype, and sample
%                           identifier
% Output:
%   T: The feature data output table, where each row represents a sample
%      (nucleus). The first three columns represent (1) Group/Phenotype, 
%      (2) replicate, and (3) Sample Identifier. Each subsequent column is  
%      an O-SNAP feature. 
% -------------------------------------------------------------------------
% Code written by:
%   Hannah Kim          Lakadamyali lab, University of Pennsylvania (USA)
% Contact:
%   hannah.kim3@pennmedicine.upenn.edu
%   melike.lakadamyali@pennmedicine.upenn.edu
% If used, please cite:
%   ....
% -------------------------------------------------------------------------
%%
function T = extract_OSNAP_features(SNAP_nucleus_file_list)
    %% parameters
    percentile_thresh = [40 70];
    %% define variables of interest
    vars_string = ["group","biological_replicate","name"];
    vars_morphological = [...
        "major_axis",...
        "minor_axis",...
        "convex_area",...
        "gyration_radius",...
        "eigenvalues_ratio",...
        "eigenentropy",...
        "perimeter",...
        "convex_perimeter",...
        "aspect_ratio",...
        "form_ratio",...
        "rectangularity",...
        "circularity",...
        "convex_circularity",...
        "convexity",...
        "solidity",...
        "fiber_length",...
        "fiber_width",...
        "curl",...
        "major_axis_norm_area",...
        "minor_axis_norm_area",...
        "elastic_energy_norm_area",...
        "bending_energy_norm_area"];
    vars_value = [...
        "nucleus_radius",...
        "locs_density",...
        "locs_number",...
        "elastic_energy",...
        "bending_energy",...
        "periphery_loc_density",...
        "interior_loc_density",...
        "periphery_cluster_density",...
        "interior_cluster_density",...
        "model_lad_thickness"];
    vars_ratio = [...
        "periphery_to_interior_loc_density_ratio",...
        "periphery_to_interior_dbscan_cluster_density_ratio"];
    vars_ratio_components = {...
        ["periphery_loc_density","interior_loc_density"],...
        ["periphery_cluster_density","interior_cluster_density"]};
    vars_for_percentiles = ["log_voronoi_density","reduced_log_voronoi_density"];
    vars_chromatin_percentiles = table2array(rowfun(@strcat,combinations(vars_for_percentiles,"_"+percentile_thresh)))';
    vars_distribution_names = [...
        "interior_dbscan_cluster_radius",...
        "interior_dbscan_cluster_gyration_radius",...
        "interior_dbscan_cluster_density",...
        "interior_dbscan_cluster_n_locs",...
        "interior_dbscan_cluster_spacing",...
        "periphery_dbscan_cluster_radius",...
        "periphery_dbscan_cluster_gyration_radius",...
        "periphery_dbscan_cluster_density",...
        "periphery_dbscan_cluster_n_locs",...
        "model_lad_segment_length",...
        "model_lad_segment_thickness",...
        "log_voronoi_density",...
        "border_curvature"];
    dist_already_log = contains(vars_distribution_names,"log");
    vars_distribution_names_log = vars_distribution_names;
    vars_distribution_names_log(~dist_already_log) = "log_"+vars_distribution_names(~dist_already_log);
    vars_distribution = reshape(vars_distribution_names_log + ["_mean";"_std";"_skewness"],1,[]);
    % remove n_locs_skewness variables, which even after log transform is very far from normal
    vars_distribution = vars_distribution(~endsWith(vars_distribution,"_n_locs_skewness"));
    vars_lads = [...
        "interior_dbscan_cluster_n_locs",...
        "interior_dbscan_cluster_n_clusters",...
        "periphery_dbscan_cluster_n_locs",...
        "periphery_dbscan_cluster_n_clusters"];
    vars_radial_loc_density = compose("radial_loc_density_ring_%02d", 1:10);
    vars_radial_dbscan_cluster_density = compose("radial_dbscan_cluster_density_ring_%02d", 1:10);
    vars_radial_delta = [...
        "radial_loc_density_ring_gradient_major_axis",...
        "radial_loc_density_ring_gradient_minor_axis",...
        "radial_dbscan_cluster_density_ring_gradient_major_axis",...
        "radial_dbscan_cluster_density_ring_gradient_minor_axis"];
    %% TODO
    % load(SNAP_nucleus_file_list{1,"filepath"},'area_thresholds');
    area_thresholds = 10.^(1.25:0.25:2);
    %%
    vars_voronoi_cluster = reshape("voronoi_cluster"+compose("_%03.0fnm^2_",area_thresholds)+"log_"+["radius";"density";"gyration_radius"]+"_",1,[]);
    vars_voronoi_cluster = reshape(vars_voronoi_cluster + ["mean";"std";"skewness"],1,[]);
    vars_voronoi_cluster = [vars_voronoi_cluster reshape("voronoi_cluster"+compose("_%03.0fnm^2_",area_thresholds)+"clusters_per_nucleus_area",1,[])];
    vars = [vars_string,...
        vars_morphological,...
        vars_value,...
        vars_ratio,...
        vars_chromatin_percentiles,...
        vars_distribution,...
        "reduced_log_voronoi_density_mean",...
        vars_lads,...
        vars_radial_loc_density,...
        vars_radial_dbscan_cluster_density,...
        vars_radial_delta,...
        vars_voronoi_cluster];
    vars_to_load = cellstr([vars_value vars_distribution_names,...
        [ ...
        "voronoi_areas",...
        "reduced_log_voronoi_density"...
        "locs_norm",...
        "polygon",...
        "x_length",...
        "y_length",...
        "eigenvalues",...
        "radial_loc_density",...
        "radial_dbscan_cluster_density",...
        "locs_dbscan_cluster_periphery_labels",...
        "locs_dbscan_cluster_interior_labels",...
        "voronoi_cluster_radius",...
        "voronoi_cluster_density",...
        "voronoi_cluster_gyration_radius",...
        "voronoi_cluster_n_locs"]]);
    vars_to_load = setdiff(vars_to_load,'log_voronoi_density');
    % group voronoi data
    n_samp = size(SNAP_nucleus_file_list,1);
    T = table('Size',[n_samp numel(vars)], ...
        'VariableTypes',[repmat("string",numel(vars_string),1); ...
                         repmat("double",numel(vars)-numel(vars_string),1)]',...
        'VariableNames',vars);
    for s=1:n_samp
        %% string variables
        T{s,"group"} = SNAP_nucleus_file_list{s,"group"};
        T{s,"biological_replicate"} = SNAP_nucleus_file_list{s,"rep"};
        [~,a]= regexp(SNAP_nucleus_file_list{s,"name"}, ".*-([x0-9]+).*","split","tokens");
        T{s,"name"} = a{1};
        try
            data = load_variables_OSNAP(SNAP_nucleus_file_list{s,"filepath"},vars_to_load);
            data.log_voronoi_density = log10(1./(data.voronoi_areas));
            %% value variables
            for j=1:numel(vars_value)
                if ~isempty(data.(vars_value(j)))
                    T{s,vars_value(j)} = data.(vars_value(j));
                else
                    T{s,vars_value(j)} = NaN;
                end
            end
            %% ratio variables
            for j=1:numel(vars_ratio)
                v_numerator = vars_ratio_components{j}{1};
                v_denominator = vars_ratio_components{j}{2};
                if ~isempty(data.(v_numerator)) && ~isempty(data.(v_denominator))
                    T{s,vars_ratio(j)} = data.(v_numerator)/data.(v_denominator);
                else
                    T{s,vars_ratio(j)} = NaN;
                end
            end
            %% morphological variables
            locs_norm = data.locs_norm;
            % Generate convex hull
            locs_norm_downsize = locs_norm(1:1000:end,:);
            conv_hull_points = locs_norm_downsize(boundary(locs_norm_downsize,0),:); % Retrieve the actual boundary points.
            polygon_conv_hull_cluster = polyshape(conv_hull_points(1:end-1,1),conv_hull_points(1:end-1,2)); % Create a polygon of the convex hull points (which will be completely filled).
            % Store the shape descriptors: localization descriptors.
            nucleus_area = pi*T{s,"nucleus_radius"}^2;
            T{s,"major_axis"} = max([data.x_length,data.y_length]);
            T{s,"minor_axis"} = min([data.x_length,data.y_length]);
            T{s,"convex_area"} = area(polygon_conv_hull_cluster);
            T{s,"gyration_radius"} = sqrt(mean((locs_norm(:,1)-mean(locs_norm(:,1))).^2 + (locs_norm(:,2)-mean(locs_norm(:,2))).^2));
            eigenvalues = data.eigenvalues;
            T{s,"eigenvalues_ratio"} = eigenvalues(1) / eigenvalues(2);
            T{s,"eigenentropy"} = -eigenvalues(1)/sum(eigenvalues)*log(eigenvalues(1)/sum(eigenvalues)) - eigenvalues(2)/sum(eigenvalues)*log(eigenvalues(2)/sum(eigenvalues));
            % Store the shape descriptors: boundary descriptors.
            T{s,"perimeter"} = perimeter(data.polygon);
            T{s,"convex_perimeter"} = perimeter(polygon_conv_hull_cluster);
            % Store the dependent shape descriptors (coordinate-based).
            T{s,"aspect_ratio"} = T{s,"major_axis"} / T{s,"minor_axis"};
            T{s,"form_ratio"} = nucleus_area / (T{s,"major_axis"}^2);
            T{s,"rectangularity"} = nucleus_area / (T{s,"major_axis"}*T{s,"minor_axis"});
            T{s,"circularity"} = 4 * pi * nucleus_area / (T{s,"perimeter"}^2);
            T{s,"convex_circularity"} = 4 * pi*T{s,"convex_area"} / (T{s,"convex_perimeter"}^2);
            T{s,"convexity"} =  T{s,"convex_perimeter"} / T{s,"perimeter"};
            T{s,"solidity"} = nucleus_area / T{s,"convex_area"};
            T{s,"fiber_length"} = (T{s,"perimeter"} + realsqrt(abs((T{s,"perimeter"})^2 - 16 * nucleus_area))) / 4;
            T{s,"fiber_width"} = nucleus_area / T{s,"fiber_length"};
            T{s,"curl"} = T{s,"major_axis"} / T{s,"fiber_length"};
            T{s,"major_axis_norm_area"} = T{s,"major_axis"} ./ nucleus_area;
            T{s,"minor_axis_norm_area"} = T{s,"minor_axis"} ./ nucleus_area;
            T{s,"elastic_energy_norm_area"} = T{s,"elastic_energy"}./ nucleus_area;            
            T{s,"bending_energy_norm_area"} = T{s,"bending_energy"}./ nucleus_area;            
            %% chromatin variables
            for j=1:numel(vars_for_percentiles)
                percentile_values_j = prctile(data.(vars_for_percentiles(j)),percentile_thresh);
                for k=1:numel(percentile_thresh)
                    T{s,vars_for_percentiles(j)+"_"+percentile_thresh(k)} = percentile_values_j(k);
                end
            end
            T{s,"reduced_log_voronoi_density_mean"} = mean(data.reduced_log_voronoi_density,"omitmissing");
            %% distribution variables
            for j=1:numel(vars_distribution_names_log)
                prefix = vars_distribution_names_log(j);
                if ~isempty(data.(vars_distribution_names(j)))
                    if dist_already_log(j)
                        d = data.(vars_distribution_names(j));
                    else
                        d = log10(data.(vars_distribution_names(j)));
                    end
                    T{s,prefix+"_mean"} = mean(d,"omitmissing");
                    T{s,prefix+"_std"} = std(d,"omitmissing");
                    % skip skewness measurement for n_locs since
                    % distribution is not well-suited for skewness
                    % measurement
                    if ~contains(prefix,"n_locs")
                        T{s,prefix+"_skewness"} = skewness(d,1);
                    end
                else
                    T{s,prefix+["_mean","_std"]} = [NaN NaN];
                    if ~contains(prefix,"n_locs")
                        T{s,prefix+"_skewness"} = NaN;
                    end
                end
            end
            %% model lad variables
            T{s,"interior_dbscan_cluster_n_locs"} = numel(data.locs_dbscan_cluster_interior_labels);
            T{s,"interior_dbscan_cluster_n_clusters"} = numel(data.interior_dbscan_cluster_n_locs);
            T{s,"periphery_dbscan_cluster_n_locs"} = numel(data.locs_dbscan_cluster_periphery_labels);
            T{s,"periphery_dbscan_cluster_n_clusters"} = numel(data.periphery_dbscan_cluster_n_locs);            %% radial features
            for j=1:numel(vars_radial_loc_density)
                T{s,vars_radial_loc_density(j)} = data.radial_loc_density(j);
            end
            for j=1:numel(vars_radial_dbscan_cluster_density)
                T{s,vars_radial_dbscan_cluster_density(j)} = data.radial_dbscan_cluster_density(j);
            end
            prop_interior = 0.8;% proportion to consider for gradient (focus on interior of nucleus)
            n_ring = floor(numel(vars_radial_loc_density)*prop_interior);
            mdl=fitlm(linspace(0,prop_interior*T{s,"major_axis"},n_ring),data.radial_loc_density(1:n_ring));
            T{s,"radial_loc_density_ring_gradient_major_axis"} = mdl.Coefficients{2,'Estimate'};
            mdl=fitlm(linspace(0,prop_interior*T{s,"minor_axis"},n_ring),data.radial_loc_density(1:n_ring));
            T{s,"radial_loc_density_ring_gradient_minor_axis"} = mdl.Coefficients{2,'Estimate'};
            mdl=fitlm(linspace(0,prop_interior*T{s,"major_axis"},n_ring),data.radial_dbscan_cluster_density(1:n_ring));
            T{s,"radial_dbscan_cluster_density_ring_gradient_major_axis"} = mdl.Coefficients{2,'Estimate'};
            mdl=fitlm(linspace(0,prop_interior*T{s,"minor_axis"},n_ring),data.radial_dbscan_cluster_density(1:n_ring));
            T{s,"radial_dbscan_cluster_density_ring_gradient_minor_axis"} = mdl.Coefficients{2,'Estimate'};
            %% voronoi cluster features
            metrics = ["radius","density","gyration_radius"];
            for j=1:numel(metrics)
                for k=1:numel(area_thresholds)
                    prefix = sprintf("voronoi_cluster_%03.0fnm^2_log_%s_",area_thresholds(k),metrics(j));
                    d = log10(data.("voronoi_cluster_"+metrics(j)){k});
                    T{s,prefix+"mean"} = mean(d,"omitmissing");
                    T{s,prefix+"std"} = std(d,"omitmissing");
                    T{s,prefix+"skewness"} = skewness(d,1);
                end
            end
            for k=1:numel(area_thresholds)
                T{s,sprintf("voronoi_cluster_%03.0fnm^2_clusters_per_nucleus_area",area_thresholds(k))} = numel(data.voronoi_cluster_radius{k})/nucleus_area;
            end
            clearvars voronoi_data
        catch ME
            disp(SNAP_nucleus_file_list{s,"filepath"})
            disp(getReport(ME))
            T{s,4:end} = NaN(1,size(T,2)-3);
        end
    end
end

